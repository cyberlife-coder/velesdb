//! Query plan explanation for `VelesQL`.
//!
//! This module provides EXPLAIN functionality to display query execution plans.
//!
//! # Example
//!
//! ```ignore
//! use velesdb_core::velesql::{Parser, QueryPlan};
//!
//! let query = Parser::parse("SELECT * FROM docs WHERE vector NEAR $v LIMIT 10")?;
//! let plan = QueryPlan::from_select(&query.select);
//! println!("{}", plan.to_tree());
//! ```

use serde::{Deserialize, Serialize};
use std::fmt::{self, Write as _};

use super::ast::{Condition, SelectStatement};

/// Query execution plan generated by EXPLAIN.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct QueryPlan {
    /// Root node of the plan tree.
    pub root: PlanNode,
    /// Estimated execution cost in milliseconds.
    pub estimated_cost_ms: f64,
    /// Index type used (if any).
    pub index_used: Option<IndexType>,
    /// Filter strategy.
    pub filter_strategy: FilterStrategy,
}

/// A node in the query execution plan tree.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum PlanNode {
    /// Vector similarity search operation.
    VectorSearch(VectorSearchPlan),
    /// Metadata filter operation.
    Filter(FilterPlan),
    /// Limit results.
    Limit(LimitPlan),
    /// Offset skip.
    Offset(OffsetPlan),
    /// Table scan (no index).
    TableScan(TableScanPlan),
    /// Property index lookup (O(1) instead of scan).
    IndexLookup(IndexLookupPlan),
    /// Sequential operations.
    Sequence(Vec<PlanNode>),
}

/// Vector search plan details.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct VectorSearchPlan {
    /// Collection name.
    pub collection: String,
    /// `ef_search` parameter (for HNSW).
    pub ef_search: u32,
    /// Number of candidates to retrieve.
    pub candidates: u32,
}

/// Filter plan details.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct FilterPlan {
    /// Filter conditions as string representation.
    pub conditions: String,
    /// Estimated selectivity (0.0 - 1.0).
    pub selectivity: f64,
}

/// Limit plan details.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct LimitPlan {
    /// Maximum number of results.
    pub count: u64,
}

/// Offset plan details.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct OffsetPlan {
    /// Number of results to skip.
    pub count: u64,
}

/// Table scan plan (no index used).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct TableScanPlan {
    /// Collection name.
    pub collection: String,
}

/// Property index lookup plan (O(1) lookup).
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct IndexLookupPlan {
    /// Label being queried.
    pub label: String,
    /// Property name with index.
    pub property: String,
    /// Value being looked up (as string representation).
    pub value: String,
}

/// Type of index used in the query.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum IndexType {
    /// HNSW index for vector search.
    Hnsw,
    /// Flat index (brute force).
    Flat,
    /// Binary quantization index.
    BinaryQuantization,
    /// Property index for equality lookups.
    Property,
}

/// Strategy for applying filters.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
pub enum FilterStrategy {
    /// No filter.
    #[default]
    None,
    /// Pre-filtering: filter before vector search (high selectivity).
    PreFilter,
    /// Post-filtering: filter after vector search (low selectivity).
    PostFilter,
}

impl QueryPlan {
    /// Creates a new query plan from a SELECT statement.
    #[must_use]
    pub fn from_select(stmt: &SelectStatement) -> Self {
        let mut nodes = Vec::new();
        let mut has_vector_search = false;
        let mut filter_conditions = Vec::new();
        let mut filter_strategy = FilterStrategy::None;
        let mut index_used = None;

        // Analyze WHERE clause
        if let Some(ref condition) = stmt.where_clause {
            Self::analyze_condition(condition, &mut has_vector_search, &mut filter_conditions);
        }

        // Build plan nodes
        if has_vector_search {
            index_used = Some(IndexType::Hnsw);
            let candidates = u32::try_from(stmt.limit.unwrap_or(50)).unwrap_or(u32::MAX);
            nodes.push(PlanNode::VectorSearch(VectorSearchPlan {
                collection: stmt.from.clone(),
                ef_search: 100, // Default HNSW parameter
                candidates,
            }));
        } else {
            nodes.push(PlanNode::TableScan(TableScanPlan {
                collection: stmt.from.clone(),
            }));
        }

        // Add filter if needed
        if !filter_conditions.is_empty() {
            let selectivity = Self::estimate_selectivity(&filter_conditions);
            filter_strategy = if selectivity > 0.1 {
                FilterStrategy::PostFilter
            } else {
                FilterStrategy::PreFilter
            };

            nodes.push(PlanNode::Filter(FilterPlan {
                conditions: filter_conditions.join(" AND "),
                selectivity,
            }));
        }

        // Add offset before limit
        if let Some(offset) = stmt.offset {
            nodes.push(PlanNode::Offset(OffsetPlan { count: offset }));
        }

        // Add limit
        if let Some(limit) = stmt.limit {
            nodes.push(PlanNode::Limit(LimitPlan { count: limit }));
        }

        let root = if nodes.len() == 1 {
            nodes.swap_remove(0)
        } else {
            PlanNode::Sequence(nodes)
        };

        let estimated_cost_ms = Self::estimate_cost(&root, has_vector_search);

        Self {
            root,
            estimated_cost_ms,
            index_used,
            filter_strategy,
        }
    }

    /// Analyzes a condition to extract vector search and filter info.
    fn analyze_condition(
        condition: &Condition,
        has_vector_search: &mut bool,
        filter_conditions: &mut Vec<String>,
    ) {
        match condition {
            Condition::VectorSearch(_)
            | Condition::VectorFusedSearch(_)
            | Condition::Similarity(_) => {
                *has_vector_search = true;
            }
            Condition::Comparison(cmp) => {
                filter_conditions.push(format!("{} {} ?", cmp.column, cmp.operator.as_str()));
            }
            Condition::In(inc) => {
                filter_conditions.push(format!("{} IN (...)", inc.column));
            }
            Condition::Between(btw) => {
                filter_conditions.push(format!("{} BETWEEN ? AND ?", btw.column));
            }
            Condition::Like(lk) => {
                filter_conditions.push(format!("{} LIKE ?", lk.column));
            }
            Condition::IsNull(isn) => {
                let op = if isn.is_null {
                    "IS NULL"
                } else {
                    "IS NOT NULL"
                };
                filter_conditions.push(format!("{} {op}", isn.column));
            }
            Condition::Match(m) => {
                filter_conditions.push(format!("{} MATCH ?", m.column));
            }
            Condition::And(left, right) | Condition::Or(left, right) => {
                Self::analyze_condition(left, has_vector_search, filter_conditions);
                Self::analyze_condition(right, has_vector_search, filter_conditions);
            }
            Condition::Not(inner) | Condition::Group(inner) => {
                Self::analyze_condition(inner, has_vector_search, filter_conditions);
            }
        }
    }

    /// Estimates selectivity (placeholder - would need statistics in production).
    fn estimate_selectivity(conditions: &[String]) -> f64 {
        // Heuristic: more conditions = lower selectivity
        let base = 0.5_f64;
        base.powi(i32::try_from(conditions.len()).unwrap_or(i32::MAX))
    }

    /// Estimates execution cost in milliseconds.
    fn estimate_cost(root: &PlanNode, has_vector_search: bool) -> f64 {
        let base_cost = if has_vector_search { 0.05 } else { 1.0 };

        match root {
            PlanNode::Sequence(nodes) => nodes
                .iter()
                .fold(base_cost, |acc, node| acc + Self::node_cost(node)),
            _ => base_cost + Self::node_cost(root),
        }
    }

    fn node_cost(node: &PlanNode) -> f64 {
        match node {
            PlanNode::VectorSearch(_) => 0.05,
            PlanNode::Filter(f) => 0.01 * (1.0 - f.selectivity),
            PlanNode::Limit(_) | PlanNode::Offset(_) => 0.001,
            PlanNode::TableScan(_) => 1.0,
            PlanNode::IndexLookup(_) => 0.0001, // O(1) lookup is very fast
            PlanNode::Sequence(nodes) => nodes.iter().map(Self::node_cost).sum(),
        }
    }

    /// Renders the plan as a tree string.
    #[must_use]
    pub fn to_tree(&self) -> String {
        let mut output = String::from("Query Plan:\n");
        Self::render_node(&self.root, &mut output, "", true);

        let _ = write!(
            output,
            "\nEstimated cost: {:.3}ms\n",
            self.estimated_cost_ms
        );

        if let Some(ref idx) = self.index_used {
            let _ = writeln!(output, "Index used: {}", idx.as_str());
        }

        if self.filter_strategy != FilterStrategy::None {
            let _ = writeln!(output, "Filter strategy: {}", self.filter_strategy.as_str());
        }

        output
    }

    fn render_node(node: &PlanNode, output: &mut String, prefix: &str, is_last: bool) {
        let connector = if is_last { "└─ " } else { "├─ " };
        let child_prefix = format!("{}{}", prefix, if is_last { "   " } else { "│  " });

        match node {
            PlanNode::VectorSearch(vs) => {
                let _ = writeln!(output, "{prefix}{connector}VectorSearch");
                let _ = writeln!(output, "{child_prefix}├─ Collection: {}", vs.collection);
                let _ = writeln!(output, "{child_prefix}├─ ef_search: {}", vs.ef_search);
                let _ = writeln!(output, "{child_prefix}└─ Candidates: {}", vs.candidates);
            }
            PlanNode::Filter(f) => {
                let _ = writeln!(output, "{prefix}{connector}Filter");
                let _ = writeln!(output, "{child_prefix}├─ Conditions: {}", f.conditions);
                let _ = writeln!(
                    output,
                    "{child_prefix}└─ Selectivity: {:.1}%",
                    f.selectivity * 100.0
                );
            }
            PlanNode::Limit(l) => {
                let _ = writeln!(output, "{prefix}{connector}Limit: {}", l.count);
            }
            PlanNode::Offset(o) => {
                let _ = writeln!(output, "{prefix}{connector}Offset: {}", o.count);
            }
            PlanNode::TableScan(ts) => {
                let _ = writeln!(output, "{prefix}{connector}TableScan: {}", ts.collection);
            }
            PlanNode::IndexLookup(il) => {
                let _ = writeln!(
                    output,
                    "{prefix}{connector}IndexLookup({}.{})",
                    il.label, il.property
                );
                let _ = writeln!(output, "{child_prefix}└─ Value: {}", il.value);
            }
            PlanNode::Sequence(nodes) => {
                for (i, child) in nodes.iter().enumerate() {
                    Self::render_node(child, output, prefix, i == nodes.len() - 1);
                }
            }
        }
    }

    /// Renders the plan as JSON.
    ///
    /// # Errors
    ///
    /// Returns an error if serialization fails.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(self)
    }
}

impl IndexType {
    /// Returns the index type as a string.
    #[must_use]
    pub const fn as_str(&self) -> &'static str {
        match self {
            Self::Hnsw => "HNSW",
            Self::Flat => "Flat",
            Self::BinaryQuantization => "BinaryQuantization",
            Self::Property => "PropertyIndex",
        }
    }
}

impl FilterStrategy {
    /// Returns the filter strategy as a string.
    #[must_use]
    pub const fn as_str(&self) -> &'static str {
        match self {
            Self::None => "none",
            Self::PreFilter => "pre-filtering (high selectivity)",
            Self::PostFilter => "post-filtering (low selectivity)",
        }
    }
}

impl super::ast::CompareOp {
    /// Returns the operator as a string.
    #[must_use]
    pub const fn as_str(&self) -> &'static str {
        match self {
            Self::Eq => "=",
            Self::NotEq => "!=",
            Self::Gt => ">",
            Self::Gte => ">=",
            Self::Lt => "<",
            Self::Lte => "<=",
        }
    }
}

impl fmt::Display for QueryPlan {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.to_tree())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use super::super::ast::SelectColumns;

    fn make_simple_select(from: &str, limit: Option<u64>) -> SelectStatement {
        SelectStatement {
            distinct: crate::velesql::DistinctMode::None,
            columns: SelectColumns::All,
            from: from.to_string(),
            from_alias: None,
            joins: vec![],
            where_clause: None,
            order_by: None,
            limit,
            offset: None,
            with_clause: None,
            group_by: None,
            having: None,
            fusion_clause: None,
        }
    }

    #[test]
    fn test_query_plan_simple_scan() {
        let stmt = make_simple_select("docs", Some(10));
        let plan = QueryPlan::from_select(&stmt);

        assert!(plan.index_used.is_none());
        assert_eq!(plan.filter_strategy, FilterStrategy::None);
        assert!(plan.estimated_cost_ms > 0.0);
    }

    #[test]
    fn test_query_plan_with_limit_and_offset() {
        let mut stmt = make_simple_select("docs", Some(10));
        stmt.offset = Some(5);
        let plan = QueryPlan::from_select(&stmt);

        let tree = plan.to_tree();
        assert!(tree.contains("Limit"));
        assert!(tree.contains("Offset"));
    }

    #[test]
    fn test_query_plan_to_json() {
        let stmt = make_simple_select("docs", Some(10));
        let plan = QueryPlan::from_select(&stmt);

        let json = plan.to_json();
        assert!(json.is_ok());
        assert!(json.unwrap().contains("docs"));
    }

    #[test]
    fn test_query_plan_display() {
        let stmt = make_simple_select("docs", Some(10));
        let plan = QueryPlan::from_select(&stmt);

        let display = format!("{plan}");
        assert!(display.contains("Query Plan"));
    }

    #[test]
    fn test_index_type_as_str() {
        assert_eq!(IndexType::Hnsw.as_str(), "HNSW");
        assert_eq!(IndexType::Flat.as_str(), "Flat");
        assert_eq!(IndexType::BinaryQuantization.as_str(), "BinaryQuantization");
        assert_eq!(IndexType::Property.as_str(), "PropertyIndex");
    }

    #[test]
    fn test_filter_strategy_as_str() {
        assert_eq!(FilterStrategy::None.as_str(), "none");
        assert_eq!(
            FilterStrategy::PreFilter.as_str(),
            "pre-filtering (high selectivity)"
        );
        assert_eq!(
            FilterStrategy::PostFilter.as_str(),
            "post-filtering (low selectivity)"
        );
    }

    #[test]
    fn test_filter_strategy_default() {
        let strategy = FilterStrategy::default();
        assert_eq!(strategy, FilterStrategy::None);
    }

    #[test]
    fn test_node_cost_calculations() {
        let vs_plan = VectorSearchPlan {
            collection: "test".to_string(),
            ef_search: 100,
            candidates: 50,
        };
        let vs_cost = QueryPlan::node_cost(&PlanNode::VectorSearch(vs_plan));
        assert!((vs_cost - 0.05).abs() < 1e-5);

        let limit_cost = QueryPlan::node_cost(&PlanNode::Limit(LimitPlan { count: 10 }));
        assert!((limit_cost - 0.001).abs() < 1e-5);

        let ts_cost = QueryPlan::node_cost(&PlanNode::TableScan(TableScanPlan {
            collection: "test".to_string(),
        }));
        assert!((ts_cost - 1.0).abs() < 1e-5);

        let il_cost = QueryPlan::node_cost(&PlanNode::IndexLookup(IndexLookupPlan {
            label: "Person".to_string(),
            property: "id".to_string(),
            value: "123".to_string(),
        }));
        assert!((il_cost - 0.0001).abs() < 1e-6);
    }

    #[test]
    fn test_estimate_selectivity() {
        let empty: Vec<String> = vec![];
        let one = vec!["a = ?".to_string()];
        let two = vec!["a = ?".to_string(), "b = ?".to_string()];

        let s0 = QueryPlan::estimate_selectivity(&empty);
        let s1 = QueryPlan::estimate_selectivity(&one);
        let s2 = QueryPlan::estimate_selectivity(&two);

        // More conditions = lower selectivity
        assert!(s0 > s1);
        assert!(s1 > s2);
    }

    #[test]
    fn test_render_index_lookup() {
        let il = PlanNode::IndexLookup(IndexLookupPlan {
            label: "User".to_string(),
            property: "email".to_string(),
            value: "test@example.com".to_string(),
        });

        let mut output = String::new();
        QueryPlan::render_node(&il, &mut output, "", true);
        assert!(output.contains("IndexLookup"));
        assert!(output.contains("User.email"));
    }

    #[test]
    fn test_render_filter() {
        let f = PlanNode::Filter(FilterPlan {
            conditions: "status = ?".to_string(),
            selectivity: 0.25,
        });

        let mut output = String::new();
        QueryPlan::render_node(&f, &mut output, "", true);
        assert!(output.contains("Filter"));
        assert!(output.contains("Selectivity"));
    }
}
